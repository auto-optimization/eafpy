# Development notes 06.06.2023 

# PyTest
Use function style tests with assert statement such as 
```
# File is tests/t_eaf.py
def test_addone():
    assert add_one(5)==6
```
run with `pytest t_eaf.py`
## PyTest coverage
use `PyTest --cov` for generating coverage reports 
Need to use` pytest --cov src .\t_eaf.py` -> Use module name followed by test file

# Tox
Tox is a tool used to help automate testing and packaging of python projects. It automates the process of setting up virtual environments, installing dependancies and running tests. It can be used to test multiple python versions. It requires a configuration file `tox.ini`

tox.ini has a few different configurations:
```
[tox]
requires =
    tox>=4
env_list = py{38,39,310,311}
```
The `[tox]` coniguration specifies the version of tox to use, as well as which different version of tox is required.
```
[testenv]
description = run unit tests
deps =
    pytest>=7
    pytest-cov
    -r{toxinidir}/requirements_dev.txt
commands =
    pytest --cov src ./tests/t_eaf.py
```
The `[testenv]` configuration specificies the dependencies required for each environment to run the tests. A test command is specified in the `commands = ...` argument.

Other tools such as python linters and documentation builders can also be speicified by adding an extra specifiers to the `env_list`, and then creating a new section similer to `[testenv]` with the label `[testenv:linter]` for example

Tox is run by simply executing  `tox` in the command linx

# Github actions
Github actions allows for continuous integration and deployment actions to be performed using GitHub servers, after specifed events occur. For example building the package and running tests after a new commit is pushed to the repo. 

After an event, the `workflow` is defined as a set of either sequential or parralel `jobs`. Each job has a set of `actions`. These workflows are defined by `yaml` configuration files inside the `.github/workflows` folder of your repositry.

Yaml Example from [this GH tutorial](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions)
```
name: learn-github-actions
run-name: ${{ github.actor }} is learning GitHub Actions
on: [push]
jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v
```
The important settings are:
1.  `on: [push]` specifying when the events occur
2. `jobs: ` specifies all jobs to run in the workflow
    * `check-bats-version:` is a name for this job
3. `runs-on` - Configures the environment for the VM to run on eg ubuntu-latest
4. `uses: actions/checkout@v3` Runs a pre-defined action: checkout. You should use this every time the workflow runs against your code
5. `run` executes a command on the runner

# Using Tox with GH actions

Here is the example of using Tox with github actions from [this gh tutorial](https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python)

'''
name: Python package

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python: ["3.9", "3.10", "3.11"]

    steps:
      - uses: actions/checkout@v3
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python }}
      - name: Install tox and any other packages
        run: pip install tox
      - name: Run tox
        # Run tox using the version of Python in `PATH`
        run: tox -e py
Some sources prefer to install the tox-gh-actions package in the runner



# CTypes vs C extension Module
There seems to be two main ways of interfacing with C code in python. 
1. Create a C extension module. This involves creating a program in C that interacts with the Python C API. The C code will be designed in order to interact with python directly. It will be compiled into shared DLLs which can be called in python. This is complex as the Python C API must be learned and the majority of the development is in C. However calling the function in C is simple and not much boiler plate is required, and more importantly the perforance is signifcantly better. There is a tool called `SWIG` that can make the generation of these tools faster.
.
2. Use a C wrapping/ binding library. This includes `ctypes`, `CFFI`, `pybind11`

There are a few other methods available:
1. `Cython`. Cython is a superset of python that can be compiled into C code and then used as a Python C extension. 
2. `ctypesgen`. This is a tool that automaticall generates ctypes code by parsing C header files. This can save time when working with complex C libraries
3. `Boost.Python` is a C++ library used for creating Python binding for C++ code.

## AI generated comparison table
Here is a table generated by ChatGTP (3.5) that summarises different methods for interfacing between Python and C. It coud be innacurate or out of date due, and has not been fully cross-referenced as of yet.

| Method               | Description                                                      | Pros                                                         | Cons                                                                         | Suitable for Extensions/Bindings | Compatible with C++? |
|----------------------|------------------------------------------------------------------|--------------------------------------------------------------|------------------------------------------------------------------------------|----------------------------------|----------------------|
| `ctypes`             | Python library for calling C functions from Python.              | Easy to use, minimal setup, works with most C libraries.    | Slower performance compared to other methods.                                | Both                             | Yes                  |
| CFFI                 | Higher-level library for calling C functions from Python.        | Simplifies interfacing, supports structuring/marshaling data. | Requires writing CFFI-specific code, can be slower than C extensions.         | Both                             | Yes                  |
| SWIG                 | Tool for generating wrapper code to call C/C++ from Python.      | Supports multiple languages, mature and widely used.         | Configuration and learning curve, complex for simple use cases.              | Both                             | Yes (supports C++)    |
| PyBind11             | Lightweight C++ library for creating Python bindings.            | Modern C++ syntax, seamless integration with C++.           | Requires writing C++ code, learning curve for complex scenarios.              | Both                             | Yes                  |
| Python C Extension   | Writing C extension modules using the Python C API.              | Full control, high performance, direct integration.         | Complex, requires knowledge of Python C API and manual memory management.     | Extensions                       | Yes                  |
| FFI Libraries        | Libraries like `cffi` and `ffi` for interfacing with C libraries. | Simplified interface, automatic type conversion.            | Not as performant as C extensions, may have limitations for complex scenarios. | Extensions                       | Yes                  |
| Cython               | Superset of Python that can be compiled to C as a Python module. | Performance optimization, easy integration with C.           | Requires knowledge of Cython and manual type declarations.                    | Extensions                       | Yes                  |
| ctypesgen            | Automatic generation of `ctypes` code from C header files.       | Saves time by generating `ctypes` code automatically.        | May require manual adjustments for complex libraries.                         | Bindings                          | No                   |
| Boost.Python         | C++ library for creating Python bindings for C++ code.           | Comprehensive C++ integration, powerful features.          | Complex setup and build process, learning curve for new users.                | Bindings                          | Yes                  |

### Forum and blog research
This [forum comment](https://www.reddit.com/r/Python/comments/13zw527/comment/jmu6evn/?utm_source=share&utm_medium=web2x&context=3) seems to suggest that CTypes shouldn't be used in modern codebases and CFFI, PyBind11 and Swig should be used. The user suggested PyBind11 as the preffered option

# Design questions
1. Is the perforance of this library critical? 
   * Need to balance development time with perforance. C extension would be the fastest method but would require a lot more work for example.
2. Is C++ support a requirement?
3. Should the package consider updates to the EAF C library?
   * Creating a C extension would render updates to be more complex

# C compilation revision notes
1. High level source code compiled into assembly file
2. Assembly source assembled into binary file
3. Linker creates executable file from Binary file

 `gcc -S test.c` will compile into assembly file `test.s`
 `gcc -c test.c` will compile and assembly to create an `object file`
 One or more object files will be linked together in the linker to produce the executable file.
 
 The os runs a type of program called the loader to run the executable

 When including standard libraries use `#include <stdio.h>` , when using custom libraries use `#include "library.h"` 

 use `gcc -o exename main.c library.c` to produce executable file including libraries.

# Do we need more than one build per OS?
It seems that the way Python Packages work, we do not need to have seperate pack files for each distrubution, but 
